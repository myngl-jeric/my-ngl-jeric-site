<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Get Scammed</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    /* ... (styles unchanged, omitted for brevity) ... */
  </style>
</head>
<body>
  <!-- ... (UI unchanged) ... -->
  <h2>Solve the Puzzle to Continue üòè</h2>
  <div id="timer">‚è≥ 10s</div>
  <div id="puzzle-board"></div>
  <div id="troll-message" style="display:none;">
    <div class="main">
      <div class="emoji">üòÜü§≠</div>
      <h2>get scammed lel, I've got info bout u hehaheuh</h2>
      <div class="hint">
        Redirecting to your <a href="info.html">info page</a> in 5 seconds...
      </div>
    </div>
  </div>
  <div id="hacker-overlay" style="display:none;">
    <div class="hacker-content">
      <h3>üö® H4ck3r 1n73rf3r3nc3 üö®</h3>
      <div id="hacker-question"></div>
      <div id="hacker-options"></div>
      <div id="hacker-progress"></div>
      <button id="destroy-hacker" style="display:none;">Destroy Hacker</button>
    </div>
  </div>
  <form id="answer-form" action="https://formsubmit.co/notjery05@gmail.com" method="POST" style="display:none;">
    <input type="hidden" name="answers" id="answers-field">
    <!-- name field will be appended dynamically -->
  </form>
  <script>
    // --- GET USER NAME FROM ?name=... OR localStorage ---
    function getName() {
      const params = new URLSearchParams(window.location.search);
      const urlName = params.get('name');
      if (urlName && urlName.trim().length) {
        // Save for future reloads
        localStorage.setItem('userName', urlName.trim());
        return urlName.trim();
      }
      // fallback to localStorage
      return localStorage.getItem('userName') || '';
    }
    let userName = getName();

    // SETTINGS
    const imgSrc = 'https://i.imgur.com/6Kt2xTm.jpeg';
    const size = 4;
    let timeLimit = 10;
    let timeLeft = timeLimit;
    let timer = null;
    let timerRunning = false;
    let resetCount = 0;
    let board, tiles;
    let moveCount = 0;
    let movesSinceLastQ = 0;
    let questionPhase = 1; // 1 = first 5, 2 = battle, 0 = not asking
    let interruptionIndices = [3, 2, 2, 2, 2];
    let interruptionProgress = 0;

    // CRITICAL: Only ask first 5 once per session!
    let phase1QuestionsCompleted = localStorage.getItem('hackerQ1done') === 'true' ? true : false;

    const timerEl = document.getElementById('timer');
    const puzzleBoard = document.getElementById('puzzle-board');
    const trollMsg = document.getElementById('troll-message');
    const overlay = document.getElementById('hacker-overlay');
    const qDiv = document.getElementById('hacker-question');
    const optDiv = document.getElementById('hacker-options');
    const progressDiv = document.getElementById('hacker-progress');
    const destroyBtn = document.getElementById('destroy-hacker');
    const answerForm = document.getElementById('answer-form');
    const answersField = document.getElementById('answers-field');

    // Keep all answers across resets
    let allAnswers = JSON.parse(localStorage.getItem('hackerAnswers') || '[]');

    const questionsSet1 = [
      { q: "#re y0u s8ngl_?", options: ["y3s", "n0 üî•"] },
      { q: "D()g or C_t?", options: ["w00f", "M3ow"] },
      { q: "Mc*onalds or J0l√éibe3", options: ["Mcd0", "JOlLib3_"] },
      { q: 'Y0ur Ethnicity_? <u>naiintindihan mo ba ito?</u>', options: ["Oo", "what?"] },
      { q: "Wh1t ph0n3 u usin-g?", options: ["Andr0id", "IOS / Apple"] }
    ];
    const questionsSet2 = [
      { q: "Wh!ch d0 y0u pr3fer h3r3?", options: ["‚òï C0ffee", "üßã Mi1k T3a"] },
      { q: "D0 y0u w0rk0ut d@ily b@$!s?", options: ["Y3s )", "N0 )"] },
      { q: "Wh3r3 d0 y0u ch!ll 0nl1ne?", options: ["Y0uTub3", "TikT0k"] },
      { q: "W@tch 4n!m3? üëÄ", options: ["Y3s )", "N0 )"] },
      { q: "Wh0... @re y0u?", options: ["Str@ng3r", "F@m!ly", "Fri3nds w/ J3r!c", "0ld cl@ssm@te?"] }
    ];

    // --- PUZZLE LOGIC (unchanged, omitted for brevity) ---
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      while(array.every((v,i)=>v===i)) shuffle(array); // ensure not solved
      return array;
    }
    function setupBoard() {
      puzzleBoard.innerHTML = '';
      board = [];
      tiles = [];
      let positions = shuffle([...Array(size*size).keys()]);
      for (let i = 0; i < size*size; i++) {
        board[i] = positions[i];
        let tile = document.createElement('div');
        tile.className = 'tile';
        tile.draggable = true;
        tile.dataset.idx = i;
        tile.style.position = "relative";
        tile.style.zIndex = 1;
        let img = document.createElement('img');
        img.src = imgSrc;
        let x = positions[i] % size, y = Math.floor(positions[i] / size);
        img.style.left = (-x * 70) + 'px';
        img.style.top  = (-y * 70) + 'px';
        tile.appendChild(img);
        puzzleBoard.appendChild(tile);
        tiles.push(tile);
      }
      addDragDrop();
    }
    function addDragDrop() {
      tiles.forEach(tile => {
        tile.addEventListener('dragstart', dragStart);
        tile.addEventListener('dragover', dragOver);
        tile.addEventListener('dragleave', dragLeave);
        tile.addEventListener('drop', dropTile);
        tile.addEventListener('dragend', dragEnd);
      });
    }
    let dragSrcIdx = null;
    function dragStart(e) {
      dragSrcIdx = +this.dataset.idx;
      this.style.opacity = 0.5;
    }
    function dragEnd(e) {
      this.style.opacity = 1;
      tiles.forEach(t => t.classList.remove('drag-over'));
    }
    function dragOver(e) {
      e.preventDefault();
      this.classList.add('drag-over');
    }
    function dragLeave(e) {
      this.classList.remove('drag-over');
    }
    function dropTile(e) {
      e.preventDefault();
      this.classList.remove('drag-over');
      const targetIdx = +this.dataset.idx;
      if (dragSrcIdx === null || dragSrcIdx === targetIdx) return;
      [board[dragSrcIdx], board[targetIdx]] = [board[targetIdx], board[dragSrcIdx]];
      redrawTile(dragSrcIdx);
      redrawTile(targetIdx);
      dragSrcIdx = null;
      checkSolved();

      // Only ask phase 1 questions if not completed
      if (questionPhase === 1 && !phase1QuestionsCompleted) {
        moveCount++;
        movesSinceLastQ++;
        if (interruptionProgress < 5 && movesSinceLastQ >= interruptionIndices[interruptionProgress]) {
          setTimeout(() => showHackerOverlay(interruptionProgress), 150);
        }
      }
    }
    function redrawTile(idx) {
      let tile = tiles[idx];
      let boardVal = board[idx];
      let img = tile.querySelector('img');
      let x = boardVal % size, y = Math.floor(boardVal / size);
      img.style.left = (-x * 70) + 'px';
      img.style.top  = (-y * 70) + 'px';
    }
    function checkSolved() {
      if (board.every((v,i)=>v===i)) {
        clearInterval(timer);
        timerRunning = false;
        puzzleBoard.style.display = 'none';
        setTimeout(() => {
          questionPhase = 2;
          document.body.classList.add('corrupt');
          puzzleBoard.classList.add('corrupt');
          showFinalHackerBattle();
        }, 800);
      }
    }
    function updateTimerDisplay() {
      timerEl.textContent = `‚è≥ ${timeLeft}s`;
    }
    function startTimer() {
      clearInterval(timer);
      timerRunning = true;
      timeLeft = timeLimit;
      updateTimerDisplay();
      timer = setInterval(() => {
        timeLeft--;
        updateTimerDisplay();
        if (timeLeft <= 0) {
          clearInterval(timer);
          timerRunning = false;
          flyOutPiecesThenReset();
        }
      }, 1000);
    }
    function pauseTimer() {
      if (timerRunning) {
        clearInterval(timer);
        timerRunning = false;
      }
    }
    function resumeTimer() {
      if (!timerRunning) {
        timerRunning = true;
        timer = setInterval(() => {
          timeLeft--;
          updateTimerDisplay();
          if (timeLeft <= 0) {
            clearInterval(timer);
            timerRunning = false;
            flyOutPiecesThenReset();
          }
        }, 1000);
      }
    }
    function flyOutPiecesThenReset() {
      tiles.forEach((tile, i) => {
        tile.classList.add('flyout');
        tile.style.position = 'absolute';
        const row = Math.floor(i / size), col = i % size;
        tile.style.left = (col * 72) + 'px';
        tile.style.top = (row * 72) + 'px';
        const angle = Math.random() * 2 * Math.PI;
        const dist = 160 + Math.random() * 80;
        const tx = Math.cos(angle) * dist;
        const ty = Math.sin(angle) * dist;
        tile.style.transform = `translate(${tx}px, ${ty}px) rotate(${Math.random()*720-360}deg) scale(1.2)`;
        tile.style.opacity = 0;
      });
      setTimeout(doReset, 1200);
    }
    function doReset() {
      resetCount++;
      timeLimit = 10 + resetCount * 5;
      puzzleBoard.innerHTML = '';
      puzzleBoard.style.display = '';
      setupBoard();
      startTimer();
      moveCount = 0;
      movesSinceLastQ = 0;
      interruptionProgress = 0;
      // Only reset phase if we haven't finished phase 1
      if (!phase1QuestionsCompleted) {
        questionPhase = 1;
      } else {
        questionPhase = 0;
      }
    }

    // --- HACKER OVERLAY LOGIC PHASE 1 (Q1-Q5) ---
    function showHackerOverlay(questionNum) {
      pauseTimer();
      overlay.style.display = 'flex';
      showQuestionPhase1(questionNum);
    }
    function showQuestionPhase1(questionNum) {
      let qObj = questionsSet1[questionNum];
      qDiv.innerHTML = qObj.q;
      optDiv.innerHTML = '';
      qObj.options.forEach((opt, i) => {
        let btn = document.createElement('button');
        btn.type = "button";
        btn.innerHTML = opt;
        btn.onclick = function(e) {
          e.preventDefault();
          allAnswers[questionNum] = opt;
          // Save answers immediately!
          localStorage.setItem('hackerAnswers', JSON.stringify(allAnswers));
          overlay.style.display = 'none';
          interruptionProgress++;
          movesSinceLastQ = 0;
          if (questionNum === 4) {
            phase1QuestionsCompleted = true;
            localStorage.setItem('hackerQ1done', 'true');
            questionPhase = 0;
          }
          resumeTimer();
        };
        optDiv.appendChild(btn);
      });
      progressDiv.innerHTML = `Question ${questionNum+1}/5`;
      destroyBtn.style.display = "none";
    }

    // --- HACKER OVERLAY LOGIC PHASE 2 (Q6-Q10) ---
    let finalBattleIndex = 0;
    function showFinalHackerBattle() {
      overlay.style.display = 'flex';
      finalBattleIndex = 0;
      showQuestionFinalBattle();
    }
    function showQuestionFinalBattle() {
      let qObj = questionsSet2[finalBattleIndex];
      qDiv.innerHTML = qObj.q;
      optDiv.innerHTML = '';
      qObj.options.forEach((opt, i) => {
        let btn = document.createElement('button');
        btn.type = "button";
        btn.innerHTML = opt;
        btn.onclick = function(e) {
          e.preventDefault();
          allAnswers[5+finalBattleIndex] = opt;
          // Save answers immediately!
          localStorage.setItem('hackerAnswers', JSON.stringify(allAnswers));
          finalBattleIndex++;
          if (finalBattleIndex < 5) {
            showQuestionFinalBattle();
          } else {
            showDestroyHacker();
          }
        };
        optDiv.appendChild(btn);
      });
      progressDiv.innerHTML = `Battle: Question ${finalBattleIndex+6}/10`;
      destroyBtn.style.display = "none";
    }
    function showDestroyHacker() {
      qDiv.innerHTML = "<b>Y0u'v3 4nsw3r3d 4ll qu3sti0ns!</b><br><br>Pr3ss th3 butt0n b3l0w t0 d3stroy th3 h4ck3r.";
      optDiv.innerHTML = '';
      progressDiv.textContent = '';
      destroyBtn.style.display = 'block';
      destroyBtn.onclick = submitAnswers;
    }
    function submitAnswers() {
      overlay.style.display = 'none';
      answersField.value = JSON.stringify(allAnswers);

      // Remove old name field if exists
      let existingNameField = document.querySelector('input[name="name"]');
      if (existingNameField) existingNameField.remove();
      let nameField = document.createElement('input');
      nameField.type = "hidden";
      nameField.name = "name";
      nameField.value = userName;
      answerForm.appendChild(nameField);

      // Clear session so new user can play again if they reload
      localStorage.removeItem('hackerAnswers');
      localStorage.removeItem('hackerQ1done');

      answerForm.submit();
      setTimeout(() => {
        document.body.innerHTML = `
          <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;">
            <div style="font-size:3rem;margin-bottom:1rem;">üí•ü¶æ</div>
            <h2 style="color:#ffe87c;text-align:center;">HACKER DESTROYED!</h2>
            <p style="margin-top:1.5rem;color:#fff;text-align:center;">Your answers have been sent.<br>Enjoy your day üòè</p>
          </div>
        `;
      }, 300);
    }

    // --- INIT ---
    setupBoard();
    startTimer();

    document.addEventListener('keydown', function(e){
      if(overlay.style.display==='flex' && e.key==='Tab'){
        e.preventDefault();
      }
    });
  </script>
</body>
</html>